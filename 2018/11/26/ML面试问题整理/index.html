
<!DOCTYPE html>
<html lang="" class="loading">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>eggTargaryen</title>

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <meta name="keywords" content="eggTargaryen,"> 
    <meta name="description" content="个人简介：1994-2013:呆在山东潍坊​        在这里长大，读完小初高，还有大学预科班，哈哈。        
2013-2017: 呆在湖北武汉​        在wuli度过了马马虎,"> 
    <meta name="author" content="eggTargaryen"> 
    <link rel="alternative" href="atom.xml" title="eggTargaryen" type="application/atom+xml"> 
    <link rel="icon" href="/img/logo.png"> 
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <link rel="stylesheet" href="/css/diaspora.css">
</head>
</html>
<body class="loading">
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="icon-home image-icon" href="javascript:;"></a>
    <div title="播放/暂停" class="icon-play"></div>
    <h3 class="subtitle">机器学习和深度学习面试问题</h3>
    <div class="social">
        <!--<div class="like-icon">-->
            <!--<a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
        <!--</div>-->
        <div>
            <div class="share">
                <a title="获取二维码" class="icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>
    <div class="section">
        <div class="article">
    <div class="main">
        <h1 class="title">机器学习和深度学习面试问题</h1>
        <div class="stuff">
            <span>十一月 26, 2018</span>
            
  <ul class="post-tags-list"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/DL/">DL</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/ML/">ML</a></li></ul>


        </div>
        <div class="content markdown">
            <h1 id="数字图像处理"><a href="#数字图像处理" class="headerlink" title="数字图像处理"></a>数字图像处理</h1><p>1、 Canny边缘检测算法：<a href="https://zhuanlan.zhihu.com/p/42122107" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/42122107</a></p>
<p>Sobel算子，其主要用于边缘检测，在技术上它是以离散型的差分算子，用来运算图像亮度函数的梯度的近似值， Sobel算子是典型的基于一阶导数的边缘检测算子，由于该算子中引入了类似局部平均的运算，因此对噪声具有平滑作用，能很好的消除噪声的影响。Sobel算子对于象素的位置的影响做了加权，与Prewitt算子、Roberts算子相比因此效果更好。Sobel算子包含两组3x3的矩阵，分别为横向及纵向模板，将之与图像作平面卷积，即可分别得出横向及纵向的亮度差分近似值。缺点是Sobel算子并没有将图像的主题与背景严格地区分开来，换言之就是Sobel算子并没有基于图像灰度进行处理，由于Sobel算子并没有严格地模拟人的视觉生理特征，所以提取的图像轮廓有时并不能令人满意。</p>
<p><strong>Roberts算子</strong> 罗伯茨算子、Roberts算子是一种最简单的算子，是一种利用局部差分算子寻找边缘的算子，他采用对角线方向相邻两象素之差近似梯度幅值检测边缘。检测垂直边缘的效果好于斜向边缘，定位精度高，对噪声敏感,无法抑制噪声的影响。1963年，Roberts提出了这种寻找边缘的算子。Roberts边缘算子是一个2x2的模板，采用的是对角方向相邻的两个像素之差。从图像处理的实际效果来看，边缘定位较准，对噪声敏感。适用于边缘明显且噪声较少的图像分割。Roberts边缘检测算子是一种利用局部差分算子寻找边缘的算子,Robert算子图像处理后结果边缘不是很平滑。经分析，由于Robert算子通常会在图像边缘附近的区域内产生较宽的响应，故采用上述算子检测的边缘图像常需做细化处理，边缘定位的精度不是很高。</p>
<p><strong>Prewitt算子</strong> Prewitt算子是一种一阶微分算子的边缘检测，利用像素点上下、左右邻点的灰度差，在边缘处达到极值检测边缘，去掉部分伪边缘，对噪声具有平滑作用 。其原理是在图像空间利用两个方向模板与图像进行邻域卷积来完成的，这两个方向模板一个检测水平边缘，一个检测垂直边缘。经典Prewitt算子认为：凡灰度新值大于或等于阈值的像素点都是边缘点。即选择适当的阈值T，若P(i,j)≥T，则(i,j)为边缘点，P(i,j)为边缘图像。这种判定是欠合理的，会造成边缘点的误判，因为许多噪声点的灰度值也很大，而且对于幅值较小的边缘点，其边缘反而丢失了。Prewitt算子对噪声有抑制作用，抑制噪声的原理是通过像素平均，但是像素平均相当于对图像的低通滤波，所以Prewitt算子对边缘的定位不如Roberts算子。因为平均能减少或消除噪声，Prewitt梯度算子法就是先求平均，再求差分来求梯度。该算子与Sobel算子类似，只是权值有所变化，但两者实现起来功能还是有差距的，据经验得知Sobel要比Prewitt更能准确检测图像边缘​    </p>
<p>2、中值滤波和均值滤波，高斯滤波</p>
<p>​    在<a href="https://zh.wikipedia.org/wiki/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86" target="_blank" rel="noopener">图像处理</a>中，在进行如<a href="https://zh.wikipedia.org/wiki/%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B" target="_blank" rel="noopener">边缘检测</a>这样的进一步处理之前，通常需要首先进行一定程度的<a href="https://zh.wikipedia.org/wiki/%E9%99%8D%E5%99%AA" target="_blank" rel="noopener">降噪</a>。<strong>中值滤波</strong>是一种非线性<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%97%E6%BB%A4%E6%B3%A2%E5%99%A8" target="_blank" rel="noopener">数字滤波器</a>技术，经常用于去除图像或者其它信号中的<a href="https://zh.wikipedia.org/wiki/%E9%9B%9C%E8%A8%8A_(%E9%80%9A%E8%A8%8A%E5%AD%B8" target="_blank" rel="noopener">噪声</a>)。这个设计思想就是检查输入信号中的采样并判断它是否代表了信号，使用奇数个采样组成的观察窗实现这项功能。观察窗口中的数值进行排序，位于观察窗中间的<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%80%BC" target="_blank" rel="noopener">中值</a>作为输出。然后，丢弃最早的值，取得新的采样，重复上面的计算过程。<strong>可以有效去除椒盐噪声(salt-and-pepper noise)</strong></p>
<p>​    均值滤波也称为线性滤波，其采用的主要方法为邻域平均法。线性滤波的基本原理是用均值代替原图像中的各个像素值，即对待处理的当前像素点（x，y），选择一个模板，该模板由其近邻的若干像素组成，求模板中所有像素的均值，再把该均值赋予当前像素点（x，y），作为处理后图像在该点上的灰度g（x，y），即g（x，y）=1/m ∑f（x，y） m为该模板中包含当前像素在内的像素总个数。</p>
<p>​    <a href="https://zh.wikipedia.org/wiki/高斯模糊" target="_blank" rel="noopener">高斯滤波</a> 卷积核中间值大，周围越来越小</p>
<p>3、Gamma校正</p>
<p>​    简单点说就是为了处理后让图像看起来更清楚。具体看数字图像处理。3.2.3</p>
<p>4、图像特征提取三大算法</p>
<p>​    <a href="https://blog.csdn.net/hujingshuang/article/details/47337707" target="_blank" rel="noopener">HOG</a> 梯度方向直方图,hog+svm用于行人检测</p>
<p>​    LBP 局部二值模式<a href="https://blog.csdn.net/zouxy09/article/details/7929531" target="_blank" rel="noopener">csdn</a>  <a href="https://blog.csdn.net/hujingshuang/article/details/47292721" target="_blank" rel="noopener">csdn</a></p>
<p>​    Haar  <a href="https://blog.csdn.net/hujingshuang/article/details/47419505" target="_blank" rel="noopener">csdn</a> haar+adaboost人脸检测</p>
<p>​    </p>
<p>​    <strong>SIFT算法</strong>是一种提取局部特征的算法 <a href="https://blog.csdn.net/abcjennifer/article/details/7639681" target="_blank" rel="noopener">csdn</a>。<a href="https://blog.csdn.net/zddblog/article/details/7521424" target="_blank" rel="noopener">csdn</a></p>
<p>​    HOG与SIFT比较 <a href="https://www.jianshu.com/p/d94e558ebe26" target="_blank" rel="noopener">简书</a></p>
<p>5、常用的插值方法</p>
<p>​    最邻近内插法，双线性内插法，三次内插法。<a href="https://blog.csdn.net/coy_wang/article/details/5027872" target="_blank" rel="noopener">csdn</a></p>
<p>6、常用的图像分割算法</p>
<p>​    Graph Cut（图割）  <a href="https://blog.csdn.net/zouxy09/article/details/8532111" target="_blank" rel="noopener">csdn</a></p>
<p>​    GrabCut  <a href="https://blog.csdn.net/zouxy09/article/details/8534954" target="_blank" rel="noopener">csdn</a></p>
<p>​    Snake    <a href="https://blog.csdn.net/zouxy09/article/details/8712287" target="_blank" rel="noopener">csdn</a></p>
<p>​    分水岭算法  <a href="https://blog.csdn.net/iracer/article/details/49225823" target="_blank" rel="noopener">csdn</a></p>
<p>​    区域生长算法  <a href="https://blog.csdn.net/qiuqchen/article/details/45127449" target="_blank" rel="noopener">csdn</a> 区域生长算法的基本思想是将有相似性质的像素点合并到一起。对每一个区域要先指定一个种子点作为生长的起点，然后将种子点周围领域的像素点和种子点进行对比，将具有相似性质的点合并起来继续向外生长，直到没有满足条件的像素被包括进来为止。这样一个区域的生长就完成了。这个过程中有几个关键的问题：</p>
<p>1 给定种子点(种子点如何选取？)</p>
<p>​      种子点的选取很多时候都采用人工交互的方法实现，也有用其他方式的，比如寻找物体并提取物体内部点或者利用其它算法找到的特征点作为种子点。</p>
<p>2 确定在生长过程中能将相邻像素包括进来的准则</p>
<p>​     这个准则很重要：例如包括灰度值的差值；彩色图像的颜色；梯度特征，包括梯度的方向和幅值特征。该点周围的区域特征，例如harr特征，也就是区域像素和特征。<a href="https://www.cnblogs.com/love6tao/p/5164608.html" target="_blank" rel="noopener">cnblogs</a></p>
<p>7、实现resize()函数</p>
<p>​    <a href="https://blog.csdn.net/YZXnuaa/article/details/79626405" target="_blank" rel="noopener">csdn</a></p>
<p>​    <a href="https://www.cnblogs.com/skyfsm/p/7578302.html" target="_blank" rel="noopener">博客园</a></p>
<p>8、常用的图像空间。<a href="https://blog.csdn.net/baidu_18891025/article/details/81742905" target="_blank" rel="noopener">csdn</a></p>
<p>9、图像傅立叶变换 。<a href="https://blog.csdn.net/abcjennifer/article/details/7622228" target="_blank" rel="noopener">csdn</a></p>
<p>​    图像的频率是表征图像中灰度变化剧烈程度的指标，是灰度在平面空间上的梯度。如：大面积的沙漠在图像中是一片灰度变化缓慢的区域，对应的频率值很低；而对于地表属性变换剧烈的边缘区域在图像中是一片灰度变化剧烈的区域，对应的频率值较高。傅里叶变换在实际中有非常明显的物理意义，设f是一个能量有限的模拟信号，则其傅里叶变换就表示f的频谱。从纯粹的数学意义上看，傅里叶变换是将一个函数转换为一系列周期函数来处理的。从物理效果看，傅里叶变换是将图像从空间域转换到频率域，其逆变换是将图像从频率域转换到空间域。换句话说，傅里叶变换的物理意义是将图像的灰度分布函数变换为图像的频率分布函数。</p>
<p>​    傅里叶频谱图上我们看到的明暗不一的亮点，其意义是指图像上某一点与邻域点差异的强弱，即梯度的大小，也即该点的频率的大小（可以这么理解，图像中的低频部分指低梯度的点，高频部分相反）。一般来讲，梯度大则该点的亮度强，否则该点亮度弱。这样通过观察傅里叶变换后的频谱图，也叫功率图，我们就可以直观地看出图像的能量分布：如果频谱图中暗的点数更多，那么实际图像是比较柔和的（因为各点与邻域差异都不大，梯度相对较小）；反之，如果频谱图中亮的点数多，那么实际图像一定是尖锐的、边界分明且边界两边像素差异较大的。</p>
<p>傅立叶变换在图像处理以下几个话题都有重要作用：<br>​    1.图像增强与图像去噪<br>​    绝大部分噪音都是图像的高频分量，通过低通滤波器来滤除高频——噪声;  边缘也是图像的高频分量，可以通过添加高频分量来增强原始图像的边缘；<br>​    2.图像分割之边缘检测<br>​    提取图像高频分量<br>​    3.图像特征提取：<br>​    形状特征：傅里叶描述子<br>​    纹理特征：直接通过傅里叶系数来计算纹理特征<br>​    其他特征：将提取的特征值进行傅里叶变换来使特征具有平移、伸缩、旋转不变性<br>​    4.图像压缩<br>​    可以直接通过傅里叶系数来压缩数据；常用的离散余弦变换是傅立叶变换的实变换；</p>
<p>​    <a href="https://www.cnblogs.com/21207-iHome/p/6225888.html" target="_blank" rel="noopener">利用傅里叶变换去除图像中有规律的噪声</a></p>
<p>​    </p>
<p>利用低通滤波器来消减高频，可以去噪和平滑图像，（低频，代表梯度小，变换不大）</p>
<p>同理，利用高通滤波器来消减低频，可以对图像进行锐化。（高频，代表梯度大，是边界，噪声）</p>
<p>10、傅立叶分析详解 <a href="https://zhuanlan.zhihu.com/p/19763358?columnSlug=wille" target="_blank" rel="noopener">zhihu</a></p>
<h1 id="编程题-和基础题："><a href="#编程题-和基础题：" class="headerlink" title="编程题 和基础题："></a>编程题 和基础题：</h1><p>1.链表 反转：<a href="https://blog.csdn.net/eggTargaryen/article/details/84990008" target="_blank" rel="noopener">csdn</a></p>
<p>2.前序遍历，中序遍历，后序遍历的区别是根节点。</p>
<p>​    前序遍历：根左右</p>
<p>​    中序遍历：左根右</p>
<p>​    后序遍历：左右根 </p>
<p>3.<a href="https://blog.csdn.net/u010397369/article/details/38979077" target="_blank" rel="noopener">求最长公共子串</a>;同理，还有<a href="https://blog.csdn.net/v_JULY_v/article/details/6110269" target="_blank" rel="noopener">最长公共子序列问题</a></p>
<p>4.进程通信方式：<a href="https://blog.csdn.net/gatieme/article/details/50908749" target="_blank" rel="noopener">csdn</a></p>
<p>5.tcp三次握手：<a href="https://blog.csdn.net/whuslei/article/details/6667471" target="_blank" rel="noopener">主要看这第二张图</a></p>
<p><a href="https://blog.csdn.net/sssnmnmjmf/article/details/68486261" target="_blank" rel="noopener">csdn比较细</a></p>
<p>简单点说就是A向B发送一个同步请求（SYN），然后B要回复该请求，同时B也要发送一个同步请求，所以将B回复A的消息和B要发送的同步请求合并为一条消息，接着A要回复B的同步请求，所以一共三次握手，之所以要发两个同步请求是因为，A与B要互发消息。</p>
<p>同理，四次挥手也是一样的， A向B发送一个关闭请求，B确认，随后B也向A发送一个关闭请求，A确认，一共四次。</p>
<p>6.归并排序<a href="https://zh.wikipedia.org/wiki/归并排序" target="_blank" rel="noopener">wiki</a></p>
<p>7.找到数组中两数字和为指定和</p>
<p><a href="https://blog.csdn.net/woliuyunyicai/article/details/44222949" target="_blank" rel="noopener">csdn</a></p>
<p>8.c++ map和set底层实现的数据结构是红黑树 <a href="http://luodw.cc/2015/11/19/STL-map/" target="_blank" rel="noopener">blog</a></p>
<p>9、进程与线程的区别？</p>
<p>​    进程是爹妈，管着众多的线程儿子。</p>
<p>​    <a href="https://www.zhihu.com/question/25532384/answer/81152571" target="_blank" rel="noopener">知乎</a></p>
<p>​    进程是cpu资源分配的最小单位，线程是cpu调度的最小单位。</p>
<h1 id="机器学习："><a href="#机器学习：" class="headerlink" title="机器学习："></a>机器学习：</h1><p>1、bias与variance的含义？</p>
<p><a href="https://zhuanlan.zhihu.com/p/44872686" target="_blank" rel="noopener">答案</a></p>
<p>2、<a href="https://zhuanlan.zhihu.com/p/42740654" target="_blank" rel="noopener">Adaboost、GBDT与XGBoost的区别</a></p>
<p>3、softmax loss与交叉熵损失</p>
<p>​    <a href="https://blog.csdn.net/u014380165/article/details/77284921" target="_blank" rel="noopener">softmax loss</a></p>
<p>​    <a href="https://www.jianshu.com/p/c02a1fbffad6" target="_blank" rel="noopener">softmax loss推导</a></p>
<p>​    <a href="https://hit-scir.gitbooks.io/neural-networks-and-deep-learning-zh_cn/content/chap3/c3s1.html" target="_blank" rel="noopener">交叉熵</a></p>
<p>4、高斯混合模型GMM</p>
<p>​    <a href="https://zhuanlan.zhihu.com/p/30483076" target="_blank" rel="noopener">知乎</a></p>
<p>​    GMM可以用来进行图像分割</p>
<p>5、随机森林与Bagging</p>
<p>​    <a href="https://www.cnblogs.com/pinard/p/6156009.html" target="_blank" rel="noopener">博客园</a></p>
<p>​    最大区别，随机森林在生成决策树的时候只选取了部分样本的部分特征列，而Bagging用了部分样本的全部特征列。</p>
<p>6、软间隔SVM <a href="https://blog.csdn.net/robin_Xu_shuai/article/details/77051258" target="_blank" rel="noopener">csdn</a></p>
<p>7、朴素贝叶斯 VS 逻辑回归 区别                 <a href="https://blog.csdn.net/cjneo/article/details/45167223" target="_blank" rel="noopener">csdn</a></p>
<p>8、LR在特征较多时可以进行怎样的优化？ <a href="https://www.nowcoder.com/discuss/33439" target="_blank" rel="noopener">nowcoder</a></p>
<p>​    l1正则，有选择特征的作用。</p>
<p>9、SVD 奇异值分解</p>
<p>​    <a href="https://www.cnblogs.com/pinard/p/6251584.html" target="_blank" rel="noopener">cnblog</a></p>
<p>​    <a href="https://blog.csdn.net/zhongkejingwang/article/details/43053513" target="_blank" rel="noopener">csdn</a></p>
<p>​    <a href="https://blog.csdn.net/zhongkejingwang/article/details/43083603" target="_blank" rel="noopener">csdn</a></p>
<p>​    SVD主要还是将数据进行降为，然后计算相似度。</p>
<p>​    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">接下来再解释题主的问题，SVD分解在推荐系统中能够解决相似度矩阵过于稀疏的问题。在推荐系统中，用户的评分行为可以表示成一个评分矩阵R，Rij代表第i个用户对第j个物品的评分，在实际情况中，这个评分很多元素都是空的，因此评分矩阵非常的稀疏，直接用会导致模型不准确，因此，补全评分矩阵成为在做推荐之前的重要一步。</span><br><span class="line"></span><br><span class="line">依然假设现有一个评分矩阵P，首先对评分矩阵进行简单地补全，用用户的均值或者物品的平均值进行补全，得到粗略补全的矩阵R，根据SVD分解把R=UΣV，再选取奇异值最大的k个组成的对角矩阵Σ1，并且分别找到这k个奇异值中的每个值在矩阵U，V对应的行和列，得到U1，V1，从而可以得到降维的评分矩阵：</span><br><span class="line"></span><br><span class="line">R=U1Σ1V1，降维后的评分矩阵就是用户对物品的评分预测值。</span><br><span class="line"></span><br><span class="line">这只是早期推荐系统常用的分解方法，后面还有很多种涌现的SVD分解应用于推荐系统的方法，像Netflix的冠军就是利用了SVD分解，更多详情大家可以去看看相关的论文和文献。</span><br></pre></td></tr></table></figure>
<p>还有Funk-SVD算法及其改进。<a href="https://www.cnblogs.com/pinard/p/6351319.html" target="_blank" rel="noopener">cnblog</a></p>
<h1 id="深度学习："><a href="#深度学习：" class="headerlink" title="深度学习："></a>深度学习：</h1><p>1、梯度消失/爆炸原因，以及解决方法。</p>
<p><a href="https://zhuanlan.zhihu.com/p/25631496" target="_blank" rel="noopener">原因</a>,，，，<a href="https://blog.csdn.net/qq_25737169/article/details/78847691" target="_blank" rel="noopener">这个也ok</a></p>
<p>解决方法：使用ReLU代替sigmoid做激活函数，使用BN。</p>
<p>2、防止过拟合有哪些方法，看之前的文章。</p>
<p>3、手推BP</p>
<p>之前bp可以看一下，这里一个<a href="https://zhuanlan.zhihu.com/p/39314998" target="_blank" rel="noopener">简化版本</a>。</p>
<p>4、<a href="https://www.zhihu.com/question/34878706" target="_blank" rel="noopener">LSTM如何来避免梯度弥散和梯度爆炸？</a></p>
<p>5、几种优化函数比较，<a href="https://zhuanlan.zhihu.com/p/32230623" target="_blank" rel="noopener">知乎</a></p>
<p>​    sgd三宗罪：速度慢，会在沟壑两边持续震荡，容易陷入局部最优解。</p>
<p>​    sgd with Momentum：引入一阶动量，抑制了sgd震荡的问题。<a href="https://blog.csdn.net/u012968002/article/details/78579485" target="_blank" rel="noopener">相当于加了一个惯性</a></p>
<p>​    sgd with Nesterov Acceleration:使sgd可以跳出局部最优解。<a href="https://zhuanlan.zhihu.com/p/22810533" target="_blank" rel="noopener">知乎</a></p>
<p>​    AdaGrad：引入二阶动量，使得学习率变为自适应的。但容易造成训练提前终止。</p>
<p>​    AdaDelta：改进了二阶动量，避免了AdaGrad训练提前终止的问题。</p>
<p>​    Adam：同时引入了一阶动量和二阶动量。<a href="https://www.jiqizhixin.com/articles/2017-07-12?from=synced&amp;keyword=adam" target="_blank" rel="noopener">机器之心</a></p>
<p>​    Nadam：在Adam的基础上引入了Nesterov，使之跳出局部最优解。</p>
<p>​    <a href="http://ruder.io/optimizing-gradient-descent/index.html" target="_blank" rel="noopener">其他参考</a></p>
<p>6、<a href="https://zhuanlan.zhihu.com/p/32262540" target="_blank" rel="noopener">Adam那么棒，为什么还对SGD念念不忘 (2)—— Adam的两宗罪</a></p>
<p>​    罪1:可能不收敛</p>
<p>​    罪2:可能错过全局最优解。</p>
<p>7、讲一下pooling的作用， 为什么max pooling要更常用？哪些情况下，average pooling比max pooling更合适？</p>
<p>​    pooling目的是为了保持某种不变性（旋转、<strong>平移</strong>、伸缩等）</p>
<p>​    根据相关理论，特征提取的误差主要来自两个方面：（1）邻域大小受限造成的估计值方差增大；（2）卷积层参数误差造成估计均值的偏移。一般来说，average-pooling能减小第一种误差，更多的保留图像的背景信息，max-pooling能减小第二种误差，更多的保留纹理信息。</p>
<p>​    <a href="https://www.di.ens.fr/willow/pdfs/cvpr10c.pdf" target="_blank" rel="noopener">参考论文 Learning Mid-Level Features For Recognition</a></p>
<p>8、几种激活函数的比较<a href="https://blog.csdn.net/guorongronghe/article/details/70174476" target="_blank" rel="noopener">csdn</a></p>
<p>主要是sigmoid，relu，leakyrelu</p>
<p>sigmoid：优点：输出在01之间，相当于输出了 一个概率</p>
<p>​        缺点 ：容易产生梯度 消失 ，应为 导数最大也就0.25，一层乘一个这么小的数，层数多了梯度 消失 很正常，可以看 梯度 消失的 原因。</p>
<p>relu：优点：方便计算，因为导数是常数。收敛速度快。缓解了 梯度消失的问题</p>
<p>缺点：可能出现神经元死亡，权重无法更新 的情况。</p>
<p>lrelu：优点：避免了relu的神经元死亡 的现象。</p>
<p>9、ResNet</p>
<p>残差网络主要解决了网络退化的问题（随着网络的深度增加，准确度反而下降了）。而不是梯度消失。</p>
<p>实线shortcut connections与虚线的区别。</p>
<ul>
<li>实线的Connection部分，表示通道相同，如上图的第一个粉色矩形和第三个粉色矩形，都是3x3x64的特征图，由于通道相同，所以采用计算方式为H(x)=F(x)+x</li>
<li>虚线的的Connection部分，表示通道不同，如上图的第一个绿色矩形和第三个绿色矩形，分别是3x3x64和3x3x128的特征图，通道不同，采用的计算方式为H(x)=F(x)+Wx，其中W是卷积操作，用来调整x维度的。</li>
</ul>
<p>10、Mask R-CNN</p>
<p>11、语义分割</p>
<p>12、感受野</p>
<p>​    定义：在卷积神经网络中，感受野的定义是 卷积神经网络每一层输出的特征图（feature map）上的像素点在<strong>原始图像</strong>上映射的区域大小。 ——博客园</p>
<p>13、feature map size 计算</p>
<p>​     h1=(h0+2*pad-kernel_size)/stride+1</p>
<p>​     w1=(w0+2*pad-kernel_size)/stride+1</p>
<p>当stride=1时，若pad=(kernel_size-1)/2,那么feature map size 不变。</p>
<p>14、Inception网络特点</p>
<p>​    <a href="https://zhuanlan.zhihu.com/p/30756181" target="_blank" rel="noopener">知乎</a></p>
<p>​    在深度方向上叠加。</p>
<p>​    目的：增加网络的宽度和深度，同时用尽量少的参数。</p>
<p>​    用1X1卷积核来降低feature map深度，从而减少参数。</p>
<p>15、权重初始化方法都有哪些？<a href="https://blog.csdn.net/mzpmzk/article/details/79839047" target="_blank" rel="noopener">csdn</a></p>
<p>​    一般<strong>我们希望数据和参数的均值都为 0，输入和输出数据的方差一致。</strong></p>
<p>​    一般有随机初始化，使用预训练模型的参数初始化。</p>
<p>16、常见损失函数</p>
<p>​    均方差，用于y是高斯分布。</p>
<p>​    交叉熵，用于y是伯努利分布（01分布）</p>
<p>​    //softmax loss ，多分类。</p>
<p>17、人脸识别</p>
<p>18、自动编码器</p>
<p>​    自动编码器是一种有三层的神经网络：输入层、隐藏层（编码层）和解码层。该网络的目的是重构其输入，使其隐藏层学习到该输入的良好表征。</p>
<p>19、数据不均衡如何处理？</p>
<p>​    扩大数据集。如数据增广。或者把少数类地 数据复制几份，并适当加噪声。相当于新的样本了。</p>
<p>​    加大小样本的损失。</p>
<p>​    尝试其他分类算法如，决策树。</p>
<p>​    </p>
<p>20、1X1卷积核的作用</p>
<p>​    <strong>1×1卷积核可以起到一个跨通道聚合的作用</strong>，</p>
<p>​    <strong>所以进一步可以起到降维（或者升维）的作用，起到减少参数的目的</strong>。</p>
<p>21、attention is all you need   </p>
<p>​    <a href="https://kexue.fm/archives/4765" target="_blank" rel="noopener">blog</a></p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="http://music.163.com/song/media/outer/url?id=31134451">
            </audio>
            
        </div>
        
    <div id="gitalk-container" class="comment link" data-ae="false" data-ci="389843d8e8f4a64fb373" data-cs="4aa2f626551b60a563b935cf7f7c5273b68b28aa" data-r="blogissue" data-o="eggtargaryen" data-a="eggtargaryen" data-d="false">查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/diaspora.js"></script>
<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>




</html>